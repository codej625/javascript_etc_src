//예외발생할 가능성이 있는 문장 
try {

}
// ExceptionN이 발생했을 경우, 이를 처리하기 위한 로직
catch(Exception1 e1) {

}
// ExceptionN이 발생했을 경우, 이를 처리하기 위한 로직
catch(Exception2 e2) { 

}
// 예외발생여부에 관계없이 수행되어야 하는 로직
finally{ 

}
/*
    1) Exception
    try 문에서 Exception 예외가 발생할 경우 catch (Exception e) 로 빠져서 그 안의 실행문을 실행한다.
    마지막의 finally블럭은 try-catch문과 함께 예외발생 여부과 관계없이 "항상. 무조건" 실행되어야할 코드를 적는다.
    필수는 아니며 마지막에 선택적으로 덧붙여 사용한다.
    예외 발생시 try -> catch -> finally 순으로, 발생 하지 않은 경우 try -> finally 순으로 실행된다.
    finally 없으면 Exception 예외가 없을경우 다음 로직이 실행된다.

    - finally 블록은 어떤 경우에 사용할까?
      보통은 자원이나 DB에 커넥션 한 경우, 파일 닫기, 연결 닫기(close) 등과 같은 "정리" 코드를 넣는 데 사용된다.

    - try-catch문 플로우 

    1. 예외가 try 블럭에서 발생한 경우
    발생한 예외와 일치하는 catch 문이 있는지 확인. 
    일치하는 catch 문이 있다면 catch 블럭 내의 문장을 모두 실행하고 try catch 문을 빠져나가서 그다음 문장을 수행.
    일치하는 catch 문이 없다면 예외는 처리되지 못하고 에러 발생.

    2. 예외가 try 블럭 안에서 발생하지 않은 경우
    catch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 수행을 계속한다. 

    3.예외가 try 블럭 밖에서 발생한 경우
    예외는 아무 처리되지 못한 채 에러 발생

    - Try-catch블럭에서 예외 발생시, 예외가 발생한 위치 이후에 있는 try블럭의 문장들은 수행되지 않으므로, try블럭에 포함시킬 코드의 범위를 잘 선택해야한다. 

    - printStackTrace()
      예외발생당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메세지를 콘솔화면에 출력한다. getMessage 와는 다르게 printStackTrace는 리턴값이 없다. 
      이 메소드를 호출하면 메소드가 내부적으로 예외 결과를 화면에 출력한다. printStackTrace는 가장 자세한 예외 정보를 제공한다.

    - getMessage()
      발생한 예외클래스의 인스턴스에 저장된 메세지를 얻을 수 있음.
      오류에 대한 기본적인 내용을 알수 있지만 상세하지 않다. 

    2) 예외 던지기
    throw e
    예외 던지기 (발생시키기)
    throw 키워드를  사용하여 프로그래머가 고의로 예외를 발생시킬수 있다.

    - 예외던지기 플로우 

    1. try안에서 연산자 new를 이용해서 발생시키려는 예외클래스의 객체생성.

    2. 키워드 throw를 사용해서 생성한 예외를 catch로 던진다. 

    3. catch 에서 던진 예외를 잡아서 확인 또는 처리한다. 
*/
